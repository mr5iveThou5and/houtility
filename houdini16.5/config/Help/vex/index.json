{"body": [{"indent": 0, "text": ["VEX"], "type": "title", "level": 0}, {"indent": 0, "type": "summary", "text": ["VEX is a high-performance expression language used in many places in Houdini, such as writing shaders."]}, {"indent": 0, "type": "para", "text": ["VEX evaluation is typically very efficient giving performance\nclose to compiled C/C++ code. VEX is ", {"text": ["not"], "type": "em"}, " an alternative to\n", {"text": ["scripting"], "fullpath": "/hom/index", "scheme": null, "type": "link", "value": "/hom/"}, ", but rather a smaller, more efficient\ngeneral purpose language for writing shaders and custom nodes."]}, {"indent": 0, "type": "para", "text": ["VEX is loosely based on the C language, but takes ideas from C++ as well\nas the RenderMan shading language."]}, {"indent": 0, "type": "para", "text": ["VEX is used in several places in Houdini:"]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "text": ["Rendering \u2013 mantra uses VEX for all shading computation. This includes light, surface, displacement and fog shaders."]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": ["compositing"], "fullpath": "/composite/index", "scheme": null, "type": "link", "value": "/composite/"}, " \u2013 The ", {"text": ["VEX Generator"], "fullpath": "/nodes/cop2/vexgenerate", "scheme": "Node", "type": "link", "value": "/nodes/cop2/vexgenerate"}, " and ", {"text": ["VEX Filter"], "fullpath": "/nodes/cop2/vexfilter", "scheme": "Node", "type": "link", "value": "/nodes/cop2/vexfilter"}, " COPs allows you to write complex custom COPs in VEX. The expressions evaluate very close to C/C++ speeds and run 1000's of times faster than the Pixel Expression COP."]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": ["Particles"], "fullpath": "/particles/index", "scheme": null, "type": "link", "value": "/particles/"}, " \u2013 The ", {"text": ["POP VOP"], "fullpath": "/nodes/dop/popvop", "scheme": "Node", "type": "link", "value": "/nodes/dop/popvop"}, " allows you to do almost anything that POPs can do themselves. It is possible to write one single VEX function which performs the task of many POPs. Because the VEX code is localized to one single operator, the VEX code will typically run faster than a network of POPs."]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": ["Modeling"], "fullpath": "/model/index", "scheme": null, "type": "link", "value": "/model/"}, " \u2013 The ", {"text": ["VEX SOP"], "fullpath": "/nodes/sop/vex", "scheme": "Node", "type": "link", "value": "/nodes/sop/vex"}, " allows you to write a custom surface node that manipulates point attributes. This can move points around, adjust velocities, change colors. As well, you can group points or do many other useful tasks. VEX SOPs typically run 10 or more times faster than a point SOP."]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": ["CHOPs"], "fullpath": "/nodes/chop/index", "scheme": null, "type": "link", "value": "/nodes/chop/"}, " \u2013 The ", {"text": ["VEX CHOP"], "fullpath": "/nodes/chop/vex", "scheme": "Node", "type": "link", "value": "/nodes/chop/vex"}, " lets you to custom CHOPs. The CHOP functions can manipulate arbitrary numbers of input channels and process channel data in arbitrary ways. In some cases, the VEX code can run faster than compiled C++ code."]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": ["Fur"], "fullpath": "/fur/index", "scheme": null, "type": "link", "value": "/fur/"}, " \u2013 Procedural fur behavior is implemented with VEX."]}], "container": true, "type": "bullet_group"}, {"body": [{"body": [{"body": [{"indent": 0, "role": "item", "type": "subtopics_item", "text": [" ", {"text": "", "fullpath": "/vex/lang", "scheme": null, "type": "link", "value": "lang"}]}, {"indent": 0, "role": "item", "type": "subtopics_item", "text": [" ", {"text": "", "fullpath": "/vex/statement", "scheme": null, "type": "link", "value": "statement"}]}, {"indent": 0, "role": "item", "type": "subtopics_item", "text": [" ", {"text": "", "fullpath": "/vex/arrays", "scheme": null, "type": "link", "value": "arrays"}]}, {"indent": 0, "role": "item", "type": "subtopics_item", "text": [" ", {"text": "", "fullpath": "/vex/vcc", "scheme": null, "type": "link", "value": "vcc"}]}, {"indent": 0, "role": "item", "type": "subtopics_item", "text": [" ", {"text": "", "fullpath": "/vex/pragmas", "scheme": null, "type": "link", "value": "pragmas"}]}, {"indent": 0, "role": "item", "type": "subtopics_item", "text": [" ", {"text": "", "fullpath": "/vex/shadercalls", "scheme": null, "type": "link", "value": "shadercalls"}]}], "container": true, "role": "item_group", "type": "subtopics_item_group"}], "indent": 0, "level": 2, "text": ["Language"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"indent": 0, "role": "item", "type": "subtopics_item", "text": [" ", {"text": "", "fullpath": "/vex/snippets", "scheme": null, "type": "link", "value": "snippets"}]}, {"indent": 0, "role": "item", "type": "subtopics_item", "text": [" ", {"text": "", "fullpath": "/vex/geometry", "scheme": null, "type": "link", "value": "geometry"}]}, {"indent": 0, "role": "item", "type": "subtopics_item", "text": [" ", {"text": "", "fullpath": "/vex/pbr", "scheme": null, "type": "link", "value": "pbr"}]}, {"indent": 0, "role": "item", "type": "subtopics_item", "text": [" ", {"text": "", "fullpath": "/vex/cookbook", "scheme": null, "type": "link", "value": "cookbook"}]}, {"indent": 0, "role": "item", "type": "subtopics_item", "text": [" ", {"text": "", "fullpath": "/vex/halfedges", "scheme": null, "type": "link", "value": "halfedges"}]}, {"indent": 0, "role": "item", "type": "subtopics_item", "text": [" ", {"text": "", "fullpath": "/vex/random", "scheme": null, "type": "link", "value": "random"}]}, {"indent": 0, "role": "item", "type": "subtopics_item", "text": [" ", {"text": "", "fullpath": "/vex/sopnodes", "scheme": null, "type": "link", "value": "sopnodes"}]}, {"indent": 0, "role": "item", "type": "subtopics_item", "text": [" ", {"text": "", "fullpath": "/vex/vop_structs", "scheme": null, "type": "link", "value": "vop_structs"}]}, {"indent": 0, "role": "item", "type": "subtopics_item", "text": [" ", {"text": "", "fullpath": "/vex/assertions", "scheme": null, "type": "link", "value": "assertions"}]}], "container": true, "role": "item_group", "type": "subtopics_item_group"}], "indent": 0, "level": 2, "text": ["Next steps"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"indent": 0, "role": "item", "type": "subtopics_item", "text": [" ", {"text": "", "fullpath": "/vex/contexts/index", "scheme": null, "type": "link", "value": "contexts/"}]}, {"indent": 0, "role": "item", "type": "subtopics_item", "text": [" ", {"text": "", "fullpath": "/vex/functions/index", "scheme": null, "type": "link", "value": "functions/"}]}, {"indent": 0, "role": "item", "type": "subtopics_item", "text": [" ", {"text": "", "fullpath": "/vex/strings", "scheme": null, "type": "link", "value": "strings"}]}], "container": true, "role": "item_group", "type": "subtopics_item_group"}], "indent": 0, "level": 2, "text": ["Reference"], "container": true, "type": "h", "id": null}], "indent": 0, "level": 1, "text": "Subtopics", "role": "section", "container": true, "type": "subtopics_section", "id": "subtopics"}], "summary": ["VEX is a high-performance expression language used in many places in Houdini, such as writing shaders."], "type": "root", "attrs": {}, "title": ["VEX"]}