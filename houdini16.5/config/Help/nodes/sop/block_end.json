{"body": [{"indent": 0, "text": ["Block End"], "type": "title", "level": 0}, {"indent": 0, "type": "summary", "text": ["The end/output of a looping block."]}, {"indent": 0, "type": "para", "text": ["See ", {"text": ["looping in geometry networks"], "fullpath": "/model/looping", "scheme": null, "type": "link", "value": "/model/looping"}, " for general information on how to use this node and ", {"text": ["Block Begin"], "fullpath": "/nodes/sop/block_begin", "scheme": "Node", "type": "link", "value": "/nodes/sop/block_begin"}, "."]}, {"body": [{"indent": 0, "type": "para", "text": ["The node will present a different interface based on whether it is working on pieces."]}, {"indent": 0, "type": "para", "text": ["If the node is in Auto Detect from Inputs, it will use this approach:"]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "text": ["When the Block Begin node referenced in the ", {"text": ["Piece Block Path"], "type": "ui"}, " parameter is set to \"Fetch piece\", or when the second input of this node is connected, the node is in \"piecewise\" mode and will show parameters related to pieces. You do not need to set the number of iterations because it will automatically iterate over each piece."]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": ["Otherwise, the node is in \"repetition\" mode and will show parameters allowing you to set the number of iterations."]}], "container": true, "type": "bullet_group"}, {"indent": 0, "type": "para", "text": ["Otherwise, the Iteration Method controls the repetition mode."]}], "indent": 0, "level": 2, "text": ["Repetition mode vs. piecewise mode"], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "text": ["Iteration Method:"]}, {"body": [{"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["If the second input is present, the Piece iteration method is used\n        across that geometry.  Similarly, if the Piece Block Path exists,\n        the Piece Iteration method is used across the Piece Block\u2019s input.\n        If neither of these are the case, the Count method is used."]}], "indent": 4, "type": "dt", "text": ["Auto Detect from Inputs"]}, {"body": [{"indent": 8, "type": "para", "text": ["One iteration will be done for each piece in the template geometry.\n        If no template geometry is wired up, it is an error."]}], "indent": 4, "type": "dt", "text": ["By Pieces"]}, {"body": [{"indent": 8, "type": "para", "text": ["A fixed number of iterations is performed according to the Iterations\n        parameter."]}], "indent": 4, "type": "dt", "text": ["By Count"]}], "container": true, "type": "dt_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Iteartion Method"]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Outputs the geometry from the last iteration of the loop. You would use this when the Block Begin node is set to \"Fetch feedback\", so the loop is accumulating geometry at each step and you just want the end result."]}], "indent": 4, "type": "dt", "text": ["Feedback Each Iteration"]}, {"body": [{"indent": 8, "type": "para", "text": ["Records the geometry from each iteration, and merges them together at the end. You would use this when the Block Begin node is set to \"Fetch piece\", so the loop is only modifying one piece at a time and you need to merge them together at the end."]}], "indent": 4, "type": "dt", "text": ["Merge Each Iteration"]}], "container": true, "type": "dt_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Gather Method"]}, {"body": [{"indent": 4, "type": "para", "text": ["The number of times to cook the loop. Not available in piecewise mode."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Iterations"]}, {"body": [{"indent": 4, "type": "para", "text": ["The value of the ", {"text": ["value"], "type": "code"}, " metadata attribute on the first iteration. See ", {"fragment": "#metadata", "text": ["the looping documentation"], "value": "/model/looping#metadata", "fullpath": "/model/looping#metadata", "scheme": null, "type": "link"}, " for how to use this. Not available in piecewise mode."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Start Value"]}, {"body": [{"indent": 4, "type": "para", "text": ["The amount to add to the ", {"text": ["value"], "type": "code"}, " metadata attribute after each iteration. See ", {"fragment": "#metadata", "text": ["the looping documentation"], "value": "/model/looping#metadata", "fullpath": "/model/looping#metadata", "scheme": null, "type": "link"}, " for how to use this. Not available in piecewise mode."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Increment"]}, {"body": [{"indent": 4, "type": "para", "text": ["In piecewise mode, whether to loop over primitives or points. This controls whether the piece attribute will be a point or primitive attribute. Not available in repetition mode."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Piece Element"]}, {"body": [{"indent": 4, "type": "para", "text": ["The name of a partition attribute defining pieces, where each point/primitive where the attribute has the same value is considered part of the same piece. Several tools such as ", {"text": ["Shatter"], "fullpath": "/shelf/shatter", "scheme": null, "type": "link", "value": "/shelf/shatter"}, " create this type of attribute for you. If not given, the node will simply loop over every point/primitive in the input. Not available in repetition mode."]}, {"indent": 4, "type": "para", "text": ["Partition attributes can only be integer or strings. This will be a point or primitive attribute depending on the value of ", {"text": ["Piece element"], "type": "ui"}, "."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Piece Attribute"]}, {"body": [{"indent": 4, "type": "para", "text": ["Only allow a maximum of this number of iterations. This can be useful for testing and debugging. You can also use it in piecewise mode to guard against huge input geometry."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Max Iterations"]}, {"body": [{"indent": 4, "type": "para", "text": ["The path to a Block Begin node. If the number of iterations is 0, output this Block Begin node\u2019s input."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Default Block Path"]}, {"body": [{"indent": 4, "type": "para", "text": ["The path to a Block Begin node, from which to get pieces. Alternatively you can connect the geometry containing pieces to this node\u2019s second input. Either switches the node to \"piecewise\" mode."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Piece Block Path"]}, {"body": [{"indent": 4, "type": "para", "text": ["After cooking, this node caches the output of the last iteration. This lets you debug the last iteration by moving the display flag around inside the loop. Clicking this button clears the cache, so until the node cooks again the nodes show the initial state."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Reset Cached Pass"]}, {"body": [{"indent": 4, "type": "para", "text": ["Runs a single iteration at the given offset. This is useful for debugging piecewise loops, showing the output of an individual piece/iteration."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Single Pass"]}, {"body": [{"indent": 4, "type": "para", "text": ["If this parameter is ", {"text": ["1"], "type": "code"}, " at the start of an iteration, looping stops. You can write an expression here to test some condition. For example, you could set a threshold for the number of polygons in a feedback loop."]}, {"indent": 4, "type": "para", "text": ["If the stop condition triggers before the first iteration, it is as if ", {"text": ["Max iterations"], "type": "ui"}, " was ", {"text": ["0"], "type": "code"}, ", and this node outputs the input to the ", {"text": ["Default block path"], "type": "ui"}, " node."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Stop Condition"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 1, "text": "Parameters", "role": "section", "container": true, "type": "parameters_section", "id": "parameters"}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["This network chain will be re-evaluated for each iteration.\n        Upstream Block Begin SOPs will be dirtied each pass."]}], "indent": 0, "type": "dt", "text": ["Nodes to Iterate Over"]}, {"body": [{"indent": 4, "type": "para", "text": ["A source for pieces to iterate over. Alternatively you can use the ", {"text": ["Piece block path"], "type": "ui"}, " parameter to specify the source. This should be a Block Begin node set to \"Fetch piece\"."]}], "indent": 0, "type": "dt", "text": ["Geometry Pieces to Loop Over"]}], "container": true, "type": "dt_group"}], "indent": 0, "level": 1, "text": "Inputs", "role": "section", "container": true, "type": "inputs_section", "id": "inputs"}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": ["Looping in geometry networks"], "fullpath": "/model/looping", "scheme": null, "type": "link", "value": "/model/looping"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": "", "fullpath": "/nodes/sop/block_begin", "scheme": "Node", "type": "link", "value": "/nodes/sop/block_begin"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": "", "fullpath": "/nodes/sop/copy", "scheme": "Node", "type": "link", "value": "/nodes/sop/copy"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 1, "text": "Related", "role": "section", "container": true, "type": "related_section", "id": "related"}], "summary": ["The end/output of a looping block."], "type": "root", "attrs": {"version": null, "tags": "tech, loop", "namespace": null, "internal": "block_end", "context": "sop", "type": "node", "icon": "SOP/block_end"}, "title": ["Block End"]}