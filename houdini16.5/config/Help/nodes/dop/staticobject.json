{"body": [{"indent": 0, "text": ["Static Object"], "type": "title", "level": 0}, {"indent": 0, "type": "summary", "text": ["Creates a Static Object from SOP Geometry."]}, {"indent": 0, "type": "para", "text": ["The Static Object DOP creates a static object inside the DOP simulation. It\ncreates a new object and attaches the subdata required for it to be a\nstatic object that interacts nicely with all other solvers. "]}, {"indent": 0, "type": "para", "text": ["The position and\nvelocity of this object is extracted from the animated transformation\nparameters of the source object. Thus a static object is not necessarily\nstationary. It can move through the simulation, and even deform, but is not\naffected by other objects in the simulation."]}, {"body": [{"body": [{"indent": 4, "blevel": 6, "type": "ord", "text": ["Select the geometry to convert to a static object."]}, {"indent": 4, "blevel": 6, "type": "ord", "text": ["Click the ", {"text": "", "fullpath": "/shelf/DOP/staticobject", "scheme": "Icon", "type": "link", "value": "DOP/staticobject"}, {"text": ["Static Object"], "fullpath": "/nodes/dop/staticobject", "scheme": "Node", "type": "link", "value": "/nodes/dop/staticobject"}, " tool on the ", {"text": ["Rigid Bodies"], "type": "ui"}, " tab."]}], "container": true, "type": "ord_group"}, {"indent": 4, "type": "para", "text": [{"text": "", "fullpath": "/images/shelf/static_object_before.png", "scheme": "Image", "type": "link", "value": "/images/shelf/static_object_before.png"}, "  ", {"text": "", "fullpath": "/images/shelf/static_object_after.png", "scheme": "Image", "type": "link", "value": "/images/shelf/static_object_after.png"}]}, {"indent": 4, "type": "para", "text": ["The table is the static object."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["You can ", {"text": ["transform, rotate, scale"], "fullpath": "/basics/handles_xform", "scheme": null, "type": "link", "value": "/basics/handles_xform"}, ", and ", {"text": ["keyframe"], "fullpath": "/anim/basics", "scheme": null, "type": "link", "value": "/anim/basics"}, " the static object at various frames."]}], "indent": 4, "role": "item", "type": "note", "text": [" "]}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "level": 2, "text": ["Using Static Objects"], "container": true, "type": "h", "id": "includeme"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Determines if the creation frame refers to global Houdini\n    frames (", {"text": ["$F"], "type": "code"}, ") or to simulation specific frames (", {"text": ["$SF"], "type": "code"}, ").  "]}, {"indent": 4, "type": "para", "text": ["The latter is affected by the offset time and scale time at the\n    DOP network level."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Creation Frame Specifies Simulation Frame"]}, {"body": [{"indent": 4, "type": "para", "text": ["The frame number on which the object will be created. The\n    object is created only when the current frame number is equal to\n    this parameter value. This means the DOP Network must evaluate a\n    timestep at the specified frame, or the object will not be\n    created. "]}, {"indent": 4, "type": "para", "text": ["For example, if this value is set to 3.5, the\n    ", {"text": ["Timestep"], "type": "ui"}, " parameter of the DOP Network must be changed to\n    ", {"text": ["1/(2*$FPS)"], "type": "code"}, " to ensure the DOP Network has a timestep at frame\n    3.5."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Creation Frame"]}, {"body": [{"indent": 4, "type": "para", "text": ["The name for the created object.  This is the name that shows up\n    in the details view and is used to reference this particular\n    object externally.  "]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["While it is possible to have many objects with the same name, this complicates writing references, so it is recommended to use something like ", {"text": ["$OBJID"], "type": "code"}, " in the name."]}], "indent": 4, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Object Name"]}, {"body": [{"indent": 4, "type": "para", "text": ["The path to a SOP (or an Object, in which case the display SOP\n    is used) which will be the geometry for this object. This\n    parameter can also be a list of Object or SOP paths, and can\n    include wild card specifications or operator groups or bundles."]}, {"indent": 4, "type": "para", "text": ["If multiple Objects or SOPs match this string, a separate\n    simulation object will be created for each matching SOP."]}], "indent": 0, "text": ["SOP Path"], "role": "item", "attrs": {"id": "soppath"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["The name of a primitive group within the SOP geometry. If this\n    is set, the primitives in that group are copied to make new\n    geometry owned by the DOP simulation. Otherwise the SOP geometry\n    is referenced rather than copied."]}], "indent": 0, "text": ["Primitive Group"], "role": "item", "attrs": {"id": "primgroup"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["The path to the object that is used to control the motion of the\n    static object. The animated world space transformation of this object\n    is used to position this object, and calculate its velocity."]}], "indent": 0, "text": ["OBJ Path"], "role": "item", "attrs": {"id": "objpath"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Causes the geometry for the object to be pulled from the chosen\n    SOP at each timestep. If the SOP contains animated geometry, the\n    static object\u2019s geometry will also animate."]}], "indent": 0, "text": ["Use Deforming Geometry"], "role": "item", "attrs": {"id": "animategeo"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Normally when a solver asks for geometry data in a sub-step, the\n    simulation will simply linearly interpolate position data from integral\n    frames. However, this is not exact. Turning this option on re-evaluates\n    the geometry network for each substep. This is more accurate, but can\n    be very expensive.  This setting affects the ", {"text": ["Proxy Volume"], "type": "ui"}, " geometry\n    as well if set."]}], "indent": 0, "text": ["Re-evaluate SOPs to Interpolate Geometry"], "role": "item", "attrs": {"id": "letsopsinterpolate"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["The transform of the object containing the chosen SOP is\n    applied to the geometry. This is required if there is scaling\n    applied to the source geometry at the object level. "]}, {"indent": 4, "type": "para", "text": ["If the object level scaling is animated, the ", {"text": ["Use Deforming Geometry"], "type": "ui"}, " parameter must also be turned on."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["An rbd-like object in DOPs, whether static or rbd, has two transforms. One is part of its Geometry subdata, and the other is defined by the Position data. The RBD Solver manipulates the Position data one, which does not support scaling. If you want scaling, it has to go through the Geometry transform."]}], "indent": 4, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "text": ["Use Object Transform"], "role": "item", "attrs": {"id": "usetransform"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Sets the initial active state of the object. An inactive object\n    doesn\u2019t react to other objects in the simulation. "]}, {"indent": 4, "type": "para", "text": ["If a static object\n    is made active, it should be connected to a ", {"text": ["Static Solver"], "fullpath": "/nodes/dop/staticsolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/staticsolver"}, ". This solver\n    causes the static object to behave as if it were inactive."]}], "indent": 0, "text": ["Create Active Object"], "role": "item", "attrs": {"id": "active"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Controls if the geometry is displayed in the viewport.  Does\n    not reset the simulation when it is changed."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Display Geometry"]}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"body": [{"body": [{"body": [{"type": "para", "indent": 4, "text": ["The elasticity of the object. If two objects of bounce 1.0 collide, they will rebound without losing energy. If two objects of bounce 0.0 collide, they will come to a standstill."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Bounce"]}, {"body": [{"type": "para", "indent": 4, "text": ["The tangential elasticity of the object. If two objects of bounce forward 1.0 collide, their tangential motion will be affected only by friction. If two objects of bounce forward 0.0 collide, their tangential motion will be matched."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Bounce Forward"]}, {"body": [{"type": "para", "indent": 4, "text": ["The coefficient of friction of the object. A value of 0 means the object is frictionless. "]}, {"type": "para", "indent": 4, "text": ["This governs how much the tangential velocity is affected by collisions and resting contacts."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Friction"]}, {"body": [{"type": "para", "indent": 4, "text": ["An object sliding may have a lower friction coefficient than an object at rest. This is the scale factor that relates the two. It is not a friction coefficient, but a scale between zero and one. "]}, {"type": "para", "indent": 4, "text": ["A value of one means that dynamic friction is equal to static friction. A scale of zero means that as soon as static friction is overcome the object acts without friction."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Dynamic Friction Scale"]}, {"body": [{"type": "para", "indent": 4, "text": ["Temperature marks how warm or cool an object is.  This is used in gas simulations for ignition points of fuel or for buoyancy computations.  "]}, {"type": "para", "indent": 4, "text": ["Since this does not relate directly to any real world temperature scale, ambient temperature is usually considered 0."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Temperature"]}], "type": "parameters_item_group", "container": true}], "indent": 0, "level": 2, "text": ["Physical"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Turning on this option causes the ", {"text": ["RBD solver"], "fullpath": "/nodes/dop/rbdsolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/rbdsolver"}, " to use a volume\n    representation of this object for collision detection. "]}, {"indent": 4, "type": "para", "text": ["The volume representation results in very fast collision detection\n    and very robust results that are tolerant of temporary\n    interpenetrations. The disadvantage is that a volume\n    representation cannot be used to represent a flat object such as\n    a grid, or a hollow sphere. "]}, {"indent": 4, "type": "para", "text": ["When this toggle is turned off, the collision detection is geometry-based rather than volume-based. \n    In this case, the collision code will track the trajectories of moving objects over time to find out whether collisions occurred.\n    This allows more accurate results than volume-based collision detection.\n    For this to work, ", {"text": ["Cache Simulation"], "type": "ui"}, " must be enabled on the DOP network."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Use Volume Based Collision Detection"]}, {"body": [{"indent": 4, "type": "para", "text": ["The internal representation used for collision detection is\n    converted to visible geometry. This is useful for debugging\n    problems with collision detection."]}, {"indent": 4, "type": "para", "text": ["This parameter controls the color of the guide geometry."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Collision Guide"]}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "text": ["Use ray intersection with the geometry to create an\n        accurate volumetric representation of the geometry."]}], "indent": 4, "type": "dt", "text": ["Ray Intersect"]}, {"body": [{"indent": 8, "type": "para", "text": ["Instead of using rays to determine if points are inside or\n        outside, evaluate the metaball field.  "]}, {"indent": 8, "type": "para", "text": ["This should be used\n        with ", {"text": ["Laser Scanning"], "type": "ui"}, " turned off on geometry that consists\n        solely of metaballs."]}], "indent": 4, "type": "dt", "text": ["Meta Balls"]}, {"body": [{"indent": 8, "type": "para", "text": ["Calculate the bounding box for the geometry, and create a volumetric representation that precisely fills that bounding box. This box is always axis aligned in the DOP object\u2019s local space, which is set by the position data."]}, {"body": [{"body": [{"indent": 12, "type": "para", "text": [{"text": ["Use Object Transform"], "type": "ui"}, " bakes the object transform into the geometry\u2019s transform, leaving the ", {"text": ["Position Data"], "type": "ui"}, " in world space. Turning this off causes the object transform to be send to the ", {"text": ["Position Data"], "type": "ui"}, ", which causes the object\u2019s local space to be reoriented."]}], "indent": 8, "role": "item", "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 4, "type": "dt", "text": ["Implicit Box"]}, {"body": [{"indent": 8, "type": "para", "text": ["Calculate the bounding sphere for the geometry, and create\n        a volumetric representation that precisely fills that\n        bounding sphere."]}], "indent": 4, "type": "dt", "text": ["Implicit Sphere"]}, {"body": [{"indent": 8, "type": "para", "text": ["Calculate the bounding box for the geometry, and create a\n        volumetric representation that divides that box along its\n        smallest axis. Everything below that plane is considered\n        inside, and everything above is outside. "]}, {"indent": 8, "type": "para", "text": ["This mode is primarily useful for creating ground planes or immovable\n        walls."]}], "indent": 4, "type": "dt", "text": ["Implicit Plane"]}, {"body": [{"indent": 8, "type": "para", "text": ["Use the distance to the surface or curve.  If the Offset\n        Surface is 0, no volume will be made.  A positive offset\n        surface will create just that - an offset volume around\n        the object\u2019s surface.  This is useful for turning thin\n        objects or wires into actual solids."]}], "indent": 4, "type": "dt", "text": ["Minimum"]}, {"body": [{"indent": 8, "type": "para", "text": ["The divisions are ignored in this mode, instead they are\n        computed from the first volume or VDB primitive in the geometry.\n        The computed divisions are chosen to match the voxel\n        size of the source volume.\n        The volume primitive is sampled raw and treated as a\n        signed distance field.  The assumption is that the source\n        is the output of an ", {"text": ["Iso Offset"], "fullpath": "/nodes/sop/isooffset", "scheme": "Node", "type": "link", "value": "/nodes/sop/isooffset"}, " or\n        ", {"text": ["VDB From Polygons"], "fullpath": "/nodes/sop/vdbfrompolygons", "scheme": "Node", "type": "link", "value": "/nodes/sop/vdbfrompolygons"}, " SOP.  If it isn\u2019t a true\n        signed distance fields, unusual things may happen with RBD\n        collisions."]}], "indent": 4, "type": "dt", "text": ["Volume Sample"]}], "container": true, "type": "dt_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Mode"]}, {"body": [{"indent": 4, "type": "para", "text": ["If ", {"text": ["Non Square"], "type": "ui"}, " is chosen, the specified size is divided into the given number\n    of divisions of voxels.  However, the sides of these voxels may not be\n    equal, possibly leading to distorted simulations."]}, {"indent": 4, "type": "para", "text": ["When an axis is specified, that axis is considered authoritative\n    for determining the number of divisions.  The chosen axis' size\n    will be divided by the uniform divisions to yield the voxel\n    size.  The divisions for the other axes will then be adjusted to\n    the closest integer multiple that fits in the required size."]}, {"indent": 4, "type": "para", "text": ["Finally, the size along non-chosen axes will be changed to\n    represent uniform voxel sizes.  If the ", {"text": ["Max Axis"], "type": "ui"}, " option is chosen,\n    the maximum sized axis is used."]}, {"indent": 4, "type": "para", "text": ["When ", {"text": ["By Size"], "type": "ui"}, " is chosen, the ", {"text": ["Division Size"], "type": "ui"}, " will be used to\n    compute the number of voxels that fit in the given sized box."]}], "indent": 0, "text": ["Division Method"], "role": "item", "attrs": {"id": "sdf_uniformvoxels"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["Controls the creation of the volumetric representation of this\n    object. This should be set fine enough to capture the desired\n    features of the geometry."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Divisions"]}, {"body": [{"indent": 4, "type": "para", "text": ["The resolution of the key axis on the voxel grid.  This allows you\n    to control the overall resolution with one parameter and still\n    preserve uniform voxels.  The ", {"text": ["Uniform Voxels"], "type": "ui"}, " option specifies\n    which axis should be used as the reference. It is usually safest\n    to use the maximum axis."]}], "indent": 0, "text": ["Uniform Divisions"], "role": "item", "attrs": {"id": "sdf_uniformdiv"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["The explicit size of the voxels.  The number of voxels will be\n    computed by fitting an integer number of voxels of this size into\n    the given bounds."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Division Size"]}, {"body": [{"indent": 4, "type": "para", "text": ["In laser scan mode the volumetric representation is built by\n    sending rays along the primary axes. Only the closest and\n    farthest intersections are used. The space between these two\n    points is classified as inside, and the rest outside."]}, {"indent": 4, "type": "para", "text": ["The laser scan mode will work even with geometry which has\n    poorly defined normals, self intersects, or is not fully\n    watertight. The disadvantage is that interior features can\u2019t be\n    represented as they are not detected."]}, {"indent": 4, "type": "para", "text": ["When laser scanning is turned off, the volumetric\n    representation is still built by sending rays along the primary\n    axes. All intersections are found, however. Each pair of\n    intersections is tested to see if the segment is inside or\n    outside. This relies on the normal of the geometry being well\n    defined (i.e., manifold, no self intersections), and the\n    geometry being watertight. Complicated shapes with holes can be\n    accurately represented, however."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Laser Scan"]}, {"body": [{"indent": 4, "type": "para", "text": ["Even with the best made geometry, numerical imprecision can\n    result in incorrect sign choices. This option will cause the\n    volumetric representation to be post-processed to look for\n    inconsistent signs. These are then made consistent, usually\n    plugging leaks and filling holes."]}, {"indent": 4, "type": "para", "text": ["This takes time, and can be turned off in cases where the\n    volumetric representation is known to generate without problems."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Fix Signs"]}, {"body": [{"indent": 4, "type": "para", "text": ["The ", {"text": ["Fix Signs"], "type": "ui"}, " method alone will smooth out, and usually\n    eliminate, sign inversions. However, it is possible for regions\n    of wrong-sign to become stabilized at the boundary of the\n    volumetric representation. This option will force all voxels on\n    the boundary to be marked as exterior. The ", {"text": ["Fix Signs"], "type": "ui"}, " method\n    will be much less likely to stabilize incorrectly then."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Force Bounds"]}, {"body": [{"indent": 4, "type": "para", "text": ["If you want a hollow box, one method is to build one box inside\n    the other and not use ", {"text": ["Laser Scanning"], "type": "ui"}, ". A more robust method\n    is to just specify the inner box and use sign inversion. This\n    treats everything outside of the box as inside, allowing the\n    more robust ", {"text": ["Laser Scanning"], "type": "ui"}, " method to be used."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Invert Sign"]}, {"body": [{"indent": 4, "type": "para", "text": ["After the fix signs process is complete there can still be\n    inconsistent areas in the SDF.  Large blocks can become\n    stabilized and stick out of the SDF.  A second sign sweep pass\n    can be performed to try to eliminate these blocks."]}, {"indent": 4, "type": "para", "text": ["The sign sweep threshold governs how big of a jump has to\n    occur for a sign transition to be considered inconsistent.  If\n    the values of the sdf change by more than this threshold times\n    the width of the cell, it is considered an invalid sign\n    transition.  The original geometry is then ray intersected to\n    determine inside/outside and the result used to determine\n    which sign is correct.  The correct sign is then propagated\n    forward through the model."]}], "indent": 0, "text": ["Sign Sweep Threshold"], "role": "item", "attrs": {"id": "sdf_sweepalpha"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["The sign sweeps are repeated until no signs are flipped (ie,\n    all transitions are within the threshold) or this maximum is\n    reached.  Too low of a sign sweep threshold may prevent the\n    process from converging.  Otherwise, it tends to converge very\n    quickly."]}], "indent": 0, "text": ["Max Sign Sweep Count"], "role": "item", "attrs": {"id": "sdf_sweepcount"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["A constant amount to offset the signed distance field by.\n    This can be used grow the object slightly or shrink it.  Note\n    that it can\u2019t be grown much beyond its original size or it\n    will hit the bounding box of the signed distance field."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Offset Surface"]}, {"body": [{"indent": 4, "type": "para", "text": ["This specifies the tolerance used for ray intersections\n    when computing the SDF. This value is multiplied by the size\n    of the geometry and is scale invariant."]}], "indent": 0, "text": ["Tolerance"], "role": "item", "attrs": {"id": "sdf_tol"}, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "text": ["The geometry which will be used rather than the base geometry for\n    computing the SDF.  This can be a volume or VDB in the case of Volume Sample\n    mode to allow one better control over the cached data."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Proxy Volume"]}, {"body": [{"indent": 4, "type": "para", "text": ["Controls the operation for this object\u2019s volume data."]}, {"body": [{"body": [{"indent": 8, "type": "para", "text": ["If a file with the specified name exists already, it is\n        read from disk. Otherwise the volume is created based on the\n        other parameters on this page, and the specified file is\n        created on disk. This file will never be deleted\n        automatically, even when exiting the application."]}], "indent": 4, "type": "dt", "text": ["Automatic"]}, {"body": [{"indent": 8, "type": "para", "text": ["The specified file is read from disk."]}], "indent": 4, "type": "dt", "text": ["Read Files"]}, {"body": [{"indent": 8, "type": "para", "text": ["The volume is created using the other parameters on this\n        page, and is then written to the specified file on disk."]}], "indent": 4, "type": "dt", "text": ["Write Files"]}, {"body": [{"indent": 8, "type": "para", "text": ["The file is never read or written. The parameters on this\n        page are used to create the volume."]}], "indent": 4, "type": "dt", "text": ["No Operation"]}], "container": true, "type": "dt_group"}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["File Mode"]}, {"body": [{"indent": 4, "type": "para", "text": ["The name of the file to access according to the choice of File\n    Modes above.  This is always .simdata file format.  Saving to\n    a .bgeo extension will ", {"text": ["not"], "type": "strong"}, " save a .bgeo file."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["File"]}], "container": true, "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Volume"], "container": true, "type": "h", "id": "volume"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["Chooses between colliding points against volume or colliding\n    edges against volume. "]}, {"indent": 4, "type": "para", "text": ["Optionally, the point attributes ", {"text": ["nopointvolume"], "type": "code"}, " and ", {"text": ["noedgevolume"], "type": "code"}, " may be added to the geometry to disable individual points/edges from participating in\n    collision detection against a volume object. An edge is disabled\n    if either of its endpoints is disabled."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Surface Representation"]}, {"body": [{"indent": 4, "type": "para", "text": ["This enables conversion of primitives (such as spheres) in the\n    geometry into polygons. Only polygons are used for collision\n    detection."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Convert To Poly"]}, {"body": [{"indent": 4, "type": "para", "text": ["When this flag is turned on, polygons in the geometry are\n    triangulated."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Triangulate"]}, {"body": [{"indent": 4, "type": "para", "text": ["This controls the Level Of Detail of the triangulation. It is\n    used to specify the point density in the U and V directions."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["LOD "]}, {"body": [{"indent": 4, "type": "para", "text": ["The barycenters of each polygon can be included in the\n    collision detection as points or edges (connected to the\n    vertices of the primitive)."]}], "indent": 0, "role": "item", "type": "parameters_item", "text": ["Add Barycenters"]}], "container": true, "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Surface"], "container": true, "type": "h", "id": null}], "indent": 0, "level": 2, "text": ["Collisions"], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"type": "para", "indent": 4, "text": ["Displays a visualization of the object\u2019s collision shape, including the ", {"text": ["Collision Padding"], "type": "ui"}, ". This is useful for debugging problems with\n    collision detection, but is typically slower than just displaying the object\u2019s geometry."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Show Guide Geometry"]}, {"body": [{"type": "para", "indent": 4, "text": ["Specifies the color of the guide geometry."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Color"]}, {"body": [{"type": "para", "indent": 4, "text": ["Specifies the color of the guide geometry if the object is not moving and has been deactivated by the ", {"text": ["Bullet Solver"], "fullpath": "/nodes/dop/bulletrbdsolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/bulletrbdsolver"}, "."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Deactivated Color"]}, {"body": [{"type": "para", "indent": 4, "text": ["The shape used by the Bullet engine to represent the object. The ", {"text": ["Show Guide Geometry"], "type": "ui"}, " option can be used to visualize this collision shape."]}, {"body": [{"body": [{"type": "para", "indent": 8, "text": ["Default shape for the object. The ", {"text": ["Bullet Solver"], "fullpath": "/nodes/dop/bulletrbdsolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/bulletrbdsolver"}, " will create a collision shape from the convex hull of the geometry points."]}], "type": "dt", "indent": 4, "text": ["Convex Hull"]}, {"body": [{"type": "para", "indent": 8, "text": ["The ", {"text": ["Bullet Solver"], "fullpath": "/nodes/dop/bulletrbdsolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/bulletrbdsolver"}, " will convert the geometry to polygons and create a concave collision shape from the resulting triangles.\n        This shape is useful when simulating concave objects such as a torus or a hollow tube. However, it is recommended to only use the concave\n        representation when necessary, since the convex hull representation will typically provide better performance."]}], "type": "dt", "indent": 4, "text": ["Concave"]}, {"body": [{"type": "para", "indent": 8, "text": ["Bounding box of the object."]}], "type": "dt", "indent": 4, "text": ["Box"]}, {"body": [{"type": "para", "indent": 8, "text": ["Bounding capsule of the object."]}], "type": "dt", "indent": 4, "text": ["Capsule"]}, {"body": [{"type": "para", "indent": 8, "text": ["Bounding cylinder of the object."]}], "type": "dt", "indent": 4, "text": ["Cylinder"]}, {"body": [{"type": "para", "indent": 8, "text": ["Creates a complex shape consisting of Bullet primitives (including boxes, spheres, and cylinders). You will need to use the ", {"text": ["Bake ODE SOP"], "fullpath": "/nodes/sop/bakeode", "scheme": "Node", "type": "link", "value": "/nodes/sop/bakeode"}, "."]}], "type": "dt", "indent": 4, "text": ["Compound"]}, {"body": [{"type": "para", "indent": 8, "text": ["Bounding sphere of the object."]}], "type": "dt", "indent": 4, "text": ["Sphere"]}, {"body": [{"type": "para", "indent": 8, "text": ["A static ground plane."]}], "type": "dt", "indent": 4, "text": ["Plane"]}], "type": "dt_group", "container": true}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Geometry Representation"]}, {"body": [{"type": "para", "indent": 4, "text": ["When ", {"text": ["Geometry Representation"], "type": "ui"}, " is ", {"text": ["Convex Hull"], "type": "ui"}, ", the ", {"text": ["Bullet Solver"], "fullpath": "/nodes/dop/bulletrbdsolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/bulletrbdsolver"}, " will create a compound shape that contains a separate\n    convex hull collision shape for each set of connected primitives in the geometry."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Create Convex Hull Per Set Of Connected Primitives"]}, {"body": [{"type": "para", "indent": 4, "text": ["When enabled, the object\u2019s Geometry subdata will be analyzed instead of using the Position, Rotation, Box Size, Radius, and Length values."]}, {"type": "para", "indent": 4, "text": ["When ", {"text": ["Geometry Representation"], "type": "ui"}, " is ", {"text": ["Box"], "type": "ui"}, ", ", {"text": ["Capsule"], "type": "ui"}, ", ", {"text": ["Cylinder"], "type": "ui"}, ", ", {"text": ["Sphere"], "type": "ui"}, ", or ", {"text": ["Plane"], "type": "ui"}, ", use the geometry bounds to create the shape."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["AutoFit Primitive Boxes, Capsules, Cylinders, Spheres, or Planes to Geometry"]}, {"body": [{"type": "para", "indent": 4, "text": ["Position of the object shape in the Bullet world. Available when ", {"text": ["Geometry Representation"], "type": "ui"}, " is ", {"text": ["Box"], "type": "ui"}, ", ", {"text": ["Sphere"], "type": "ui"}, ", ", {"text": ["Capsule"], "type": "ui"}, ", ", {"text": ["Cylinder"], "type": "ui"}, ", or ", {"text": ["Plane"], "type": "ui"}, "."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Position"]}, {"body": [{"type": "para", "indent": 4, "text": ["Orientation of the object shape in the Bullet world.  Available when ", {"text": ["Geometry Representation"], "type": "ui"}, " is ", {"text": ["Box"], "type": "ui"}, ", ", {"text": ["Capsule"], "type": "ui"}, ", ", {"text": ["Cylinder"], "type": "ui"}, ", or ", {"text": ["Plane"], "type": "ui"}, "."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Rotation"]}, {"body": [{"type": "para", "indent": 4, "text": ["The half extents of the box shape. Available when ", {"text": ["Geometry Representation"], "type": "ui"}, " is ", {"text": ["Box"], "type": "ui"}, "."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Box Size"]}, {"body": [{"type": "para", "indent": 4, "text": ["The radius of the sphere shape.  Available when ", {"text": ["Geometry Representation"], "type": "ui"}, " is ", {"text": ["Sphere"], "type": "ui"}, ", ", {"text": ["Capsule"], "type": "ui"}, ", or ", {"text": ["Cylinder"], "type": "ui"}, "."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Radius"]}, {"body": [{"type": "para", "indent": 4, "text": ["The length of the capsule or cylinder in the Y direction.  Available when ", {"text": ["Geometry Representation"], "type": "ui"}, " is ", {"text": ["Capsule"], "type": "ui"}, " or ", {"text": ["Cylinder"], "type": "ui"}, "."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Length"]}, {"body": [{"type": "para", "indent": 4, "text": ["A padding distance between shapes, which is used by the Bullet engine to improve the reliability and performance of the collision detection. You\n    may need to scale this value depending on the scale of your scene. This padding increases the size of the collision shape, so it is recommended to enable\n    ", {"text": ["Shrink Collision Geometry"], "type": "ui"}, " to prevent the collision shape from growing."]}, {"type": "para", "indent": 4, "text": ["This option is not available ", {"text": ["Plane"], "type": "ui"}, " geometry representations."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Collision Padding"]}, {"body": [{"type": "para", "indent": 4, "text": ["Shrinks the collision geometry to prevent the ", {"text": ["Collision Padding"], "type": "ui"}, " from increasing the effective size of the object."]}, {"type": "para", "indent": 4, "text": ["This can improve the simulation\u2019s performance by preventing initially closely-packed collision shapes from interpenetrating, and also removes the gap between\n    objects caused by the ", {"text": ["Collision Padding"], "type": "ui"}, "."]}, {"type": "para", "indent": 4, "text": ["When ", {"text": ["Geometry Representation"], "type": "ui"}, " is ", {"text": ["Box"], "type": "ui"}, ", ", {"text": ["Capsule"], "type": "ui"}, ", ", {"text": ["Cylinder"], "type": "ui"}, ", ", {"text": ["Compound"], "type": "ui"}, ", or ", {"text": ["Sphere"], "type": "ui"}, ", the radius and/or length of each primitive will\n    be reduced by ", {"text": ["Shrink Amount"], "type": "ui"}, "."]}, {"type": "para", "indent": 4, "text": ["When ", {"text": ["Geometry Representation"], "type": "ui"}, " is ", {"text": ["Convex Hull"], "type": "ui"}, ", each polygon in the representation geometry will be shifted inward by ", {"text": ["Shrink Amount"], "type": "ui"}, "."]}, {"type": "para", "indent": 4, "text": ["This option is not available for the ", {"text": ["Concave"], "type": "ui"}, " or ", {"text": ["Plane"], "type": "ui"}, " geometry representations."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Shrink Collision Geometry"]}, {"body": [{"type": "para", "indent": 4, "text": ["Specifies the amount of resizing done by ", {"text": ["Shrink Collision Geometry"], "type": "ui"}, ". By default, this value is equal to the ", {"text": ["Collision Padding"], "type": "ui"}, " so that\n    the resulting size of the collision shape (including the ", {"text": ["Collision Padding"], "type": "ui"}, ") is the same size as the object\u2019s geometry."]}, {"type": "para", "indent": 4, "text": ["This option is not available for the ", {"text": ["Concave"], "type": "ui"}, " or ", {"text": ["Plane"], "type": "ui"}, " geometry representations."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Shrink Amount"]}, {"body": [{"type": "para", "indent": 4, "text": ["When enabled, any impacts that occur during the simulation will be recorded in the ", {"text": ["Impacts"], "type": "ui"}, " or ", {"text": ["Feedback"], "type": "ui"}, " data. Enabling this option may cause the\n    simulation time and memory usage to increase."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Add Impact Data"]}, {"body": [{"type": "para", "indent": 4, "text": ["Disables simulation of a non-moving object until the object moves again. The linear and angular speed thresholds are used to determine whether the object is non-moving. If the ", {"text": ["Display Geometry"], "type": "ui"}, " checkbox is turned off, you will see the color of the Guide Geometry change from the ", {"text": ["Color"], "type": "ui"}, " to the ", {"text": ["Deactivated Color"], "type": "ui"}, "."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Enable Sleeping"]}, {"body": [{"type": "para", "indent": 4, "text": ["The sleeping threshold for the object\u2019s linear velocity. If the object\u2019s linear speed is below this threshold for a period of time, the object may be treated as non-moving."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Linear Threshold"]}, {"body": [{"type": "para", "indent": 4, "text": ["The sleeping threshold for the object\u2019s angular velocity. If the object\u2019s angular speed is below this threshold for a period of time, the object may be treated as non-moving."]}], "type": "parameters_item", "role": "item", "indent": 0, "text": ["Angular Threshold"]}], "type": "parameters_item_group", "container": true}], "container": true, "level": 2, "text": ["Bullet Data"], "indent": 0, "type": "h", "id": null}], "indent": 0, "level": 1, "text": "Parameters", "role": "section", "container": true, "type": "parameters_section", "id": "parameters"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "text": ["The static object created by this node is sent through the single\n    output."]}], "indent": 0, "type": "dt", "text": ["First"]}], "container": true, "type": "dt_group"}], "indent": 0, "level": 1, "text": "Outputs", "role": "section", "container": true, "type": "outputs_section", "id": "outputs"}, {"body": [{"body": [{"body": [{"type": "para", "indent": 4, "text": ["This value is the simulation time for which the node is being\n    evaluated. "]}, {"type": "para", "indent": 4, "text": ["This value may not be equal to the current Houdini time\n    represented by the variable T, depending on the settings of the ", {"text": ["DOP\n    Network"], "fullpath": "/nodes/obj/dopnet", "scheme": "Node", "type": "link", "value": "/nodes/obj/dopnet"}, " ", {"text": ["Offset Time"], "type": "ui"}, " and ", {"text": ["Time Scale"], "type": "ui"}, "\n    parameters. "]}, {"type": "para", "indent": 4, "text": ["This value is guaranteed to have a value of zero at the\n    start of a simulation, so when testing for the first timestep of a\n    simulation, it is best to use a test like ", {"text": ["$ST == 0"], "type": "code"}, " rather than\n    ", {"text": ["$T == 0"], "type": "code"}, " or ", {"text": ["$FF == 1"], "type": "code"}, "."]}], "type": "dt", "indent": 0, "text": ["ST"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value is the simulation frame (or more accurately, the\n    simulation time step number) for which the node is being evaluated."]}, {"type": "para", "indent": 4, "text": ["This value may not be equal to the current Houdini frame number\n    represented by the variable F, depending on the settings of the ", {"text": ["DOP\n    Network"], "fullpath": "/nodes/obj/dopnet", "scheme": "Node", "type": "link", "value": "/nodes/obj/dopnet"}, " parameters. Instead, this value is equal to\n    the simulation time (ST) divided by the simulation timestep size\n    (TIMESTEP)."]}], "type": "dt", "indent": 0, "text": ["SF"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value is the size of a simulation timestep. This value is\n    useful to scale values that are expressed in units per second, but\n    are applied on each timestep."]}], "type": "dt", "indent": 0, "text": ["TIMESTEP"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value is the inverse of the TIMESTEP value. It is the number\n    of timesteps per second of simulation time."]}], "type": "dt", "indent": 0, "text": ["SFPS"]}, {"body": [{"type": "para", "indent": 4, "text": ["This is the number of objects in the simulation. For nodes that\n    create objects such as the ", {"text": ["Empty Object"], "fullpath": "/nodes/dop/emptyobject", "scheme": "Node", "type": "link", "value": "/nodes/dop/emptyobject"}, " node,\n    this value will increase for each object that is evaluated. "]}, {"type": "para", "indent": 4, "text": ["A good way to guarantee unique object names is to use an expression\n    like ", {"text": ["object_$SNOBJ"], "type": "code"}, "."]}], "type": "dt", "indent": 0, "text": ["SNOBJ"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value is the number of objects that will be evaluated by the\n    current node during this timestep. This value will often be\n    different from SNOBJ, as many nodes do not process all the objects\n    in a simulation. "]}, {"type": "para", "indent": 4, "text": ["This value may return 0 if the node does not\n    process each object sequentially (such as the ", {"text": ["Group\n    DOP"], "fullpath": "/nodes/dop/group", "scheme": "Node", "type": "link", "value": "/nodes/dop/group"}, ")."]}], "type": "dt", "indent": 0, "text": ["NOBJ"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value is the index of the specific object being processed by\n    the node. This value will always run from zero to NOBJ-1 in a given\n    timestep. This value does not identify the current object within the\n    simulation like OBJID or OBJNAME, just the object\u2019s position in the\n    current order of processing. "]}, {"type": "para", "indent": 4, "text": ["This value is useful for generating a\n    random number for each object, or simply splitting the objects into\n    two or more groups to be processed in different ways. This value\n    will be -1 if the node does not process objects sequentially (such\n    as the ", {"text": ["Group DOP"], "fullpath": "/nodes/dop/group", "scheme": "Node", "type": "link", "value": "/nodes/dop/group"}, ")."]}], "type": "dt", "indent": 0, "text": ["OBJ"]}, {"body": [{"type": "para", "indent": 4, "text": ["This is the unique object identifier for the object being\n    processed. Every object is assigned an integer value that is unique\n    among all objects in the simulation for all time. Even if an object\n    is deleted, its identifier is never reused. "]}, {"type": "para", "indent": 4, "text": ["The object identifier\n    can always be used to uniquely identify a given object. This makes\n    this variable very useful in situations where each object needs to\n    be treated differently. It can be used to produce a unique random\n    number for each object, for example. "]}, {"type": "para", "indent": 4, "text": ["This value is also the best way\n    to look up information on an object using the dopfield expression\n    function. This value will be -1 if the node does not process objects\n    sequentially (such as the ", {"text": ["Group DOP"], "fullpath": "/nodes/dop/group", "scheme": "Node", "type": "link", "value": "/nodes/dop/group"}, ")."]}], "type": "dt", "indent": 0, "text": ["OBJID"]}, {"body": [{"type": "para", "indent": 4, "text": ["This string contains a space separated list of the unique object\n    identifiers for every object being processed by the current node."]}], "type": "dt", "indent": 0, "text": ["ALLOBJIDS"]}, {"body": [{"type": "para", "indent": 4, "text": ["This string contains a space separated list of the names of every\n    object being processed by the current node."]}], "type": "dt", "indent": 0, "text": ["ALLOBJNAMES"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value is the simulation time (see variable ST) at which the\n    current object was created. "]}, {"type": "para", "indent": 4, "text": ["Therefore, to check if an object was created\n    on the current timestep, the expression ", {"text": ["$ST == $OBJCT"], "type": "code"}, " should\n    always be used. This value will be zero if the node does not process\n    objects sequentially (such as the ", {"text": ["Group DOP"], "fullpath": "/nodes/dop/group", "scheme": "Node", "type": "link", "value": "/nodes/dop/group"}, ")."]}], "type": "dt", "indent": 0, "text": ["OBJCT"]}, {"body": [{"type": "para", "indent": 4, "text": ["This value is the simulation frame (see variable SF) at which the\n    current object was created. "]}, {"type": "para", "indent": 4, "text": ["This value is equivalent to using the\n    dopsttoframe expression on the OBJCT variable. This value will be\n    zero if the node does not process objects sequentially (such as the\n    ", {"text": ["Group DOP"], "fullpath": "/nodes/dop/group", "scheme": "Node", "type": "link", "value": "/nodes/dop/group"}, ")."]}], "type": "dt", "indent": 0, "text": ["OBJCF"]}, {"body": [{"type": "para", "indent": 4, "text": ["This is a string value containing the name of the object being\n    processed. "]}, {"type": "para", "indent": 4, "text": ["Object names are not guaranteed to be unique within a\n    simulation. However, if you name your objects carefully so that they\n    are unique, the object name can be a much easier way to identify an\n    object than the unique object identifier, OBJID. "]}, {"type": "para", "indent": 4, "text": ["The object name can\n    also be used to treat a number of similar objects (with the same\n    name) as a virtual group. If there are 20 objects named \"myobject\",\n    specifying ", {"text": ["strcmp($OBJNAME, \"myobject\") == 0"], "type": "code"}, " in the activation field\n    of a DOP will cause that DOP to operate only on those 20 objects. This\n    value will be the empty string if the node does not process objects\n    sequentially (such as the ", {"text": ["Group DOP"], "fullpath": "/nodes/dop/group", "scheme": "Node", "type": "link", "value": "/nodes/dop/group"}, ")."]}], "type": "dt", "indent": 0, "text": ["OBJNAME"]}, {"body": [{"type": "para", "indent": 4, "text": ["This is a string value containing the full path of the current DOP\n    Network. This value is most useful in DOP subnet digital assets\n    where you want to know the path to the DOP Network that contains the\n    node."]}], "type": "dt", "indent": 0, "text": ["DOPNET"]}], "type": "dt_group", "container": true}, {"body": [{"body": [{"type": "para", "indent": 4, "text": ["Most dynamics nodes have local variables with the same names as the\n    node\u2019s parameters. For example, in a ", {"text": ["Position node"], "fullpath": "/nodes/dop/position", "scheme": "Node", "type": "link", "value": "/nodes/dop/position"}, ",\n    you could write the expression:"]}, {"lang": null, "type": "pre", "indent": 4, "text": ["\n    $tx + 0.1\n    "]}, {"type": "para", "indent": 4, "text": ["\u2026to make the object move 0.1 units along the X axis at each timestep."]}], "role": "item", "indent": 0, "type": "note"}], "role": "item_group", "container": true, "type": "note_group"}], "indent": 0, "level": 1, "text": "Locals", "role": "section", "container": true, "type": "locals_section", "id": "locals"}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": "", "fullpath": "/nodes/dop/staticsolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/staticsolver"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": "", "fullpath": "/nodes/dop/groundplane", "scheme": "Node", "type": "link", "value": "/nodes/dop/groundplane"}]}, {"indent": 0, "blevel": 2, "type": "bullet", "text": [{"text": "", "fullpath": "/nodes/dop/terrainobject", "scheme": "Node", "type": "link", "value": "/nodes/dop/terrainobject"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 1, "text": "Related", "role": "section", "container": true, "type": "related_section", "id": "related"}], "title": ["Static Object"], "summary": ["Creates a Static Object from SOP Geometry."], "attrs": {"version": null, "namespace": null, "internal": "staticobject", "context": "dop", "type": "node", "icon": "DOP/staticobject"}, "included": ["/shelf/staticobject", "/nodes/dop/standard_locals", "/nodes/dop/standard_bulletdata_parm", "/nodes/dop/standard_rbdvolume_parms", "/nodes/dop/standard_physparms"], "type": "root"}